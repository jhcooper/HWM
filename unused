def meters_to_feet(df):
    # Convert and round water levels to feet
    df['Peak Water Level'] = df['Peak Water Level'].apply(lambda x: round(x * 3.281, 3))


def locate_parallels(filtered_df, target_df):
    # Separate date and time for filtered_df
    iltered_df.loc[:, 'Date'] = filtered_df['Date Time'].dt.date
    filtered_df.loc[:, 'Time'] = filtered_df['Date Time'].dt.time
    # Separate date and time for target_df
    target_df.loc[:, 'Date'] = target_df['Date Time'].dt.date
    target_df.loc[:, 'Time'] = target_df['Date Time'].dt.time

    dates = filtered_df['Date']
    matched_dates = target_df[target_df['Date'].isin(dates)]
    print(matched_dates)
def filter_on_day(df):
    # Helper function to isolate HWM events from a pre-filtered DataFrame
    # Parameters:
    #   df: DataFrame - a filtered csv containing all threshold exceedances
    # Returns:
    #   isolated: DataFrame - contains only threshold exceedances that do not occur within the same 24-hour period

    # Get the time difference between adjacent rows in hours

    # Convert timestamp column to datetime type
    df['Date Time'] = pd.to_datetime(df['Date Time'])
    df.reset_index(inplace=True)
    print(df)
    # Calculate time differences between adjacent rows
    time_diffs = df['Date Time'].diff()

    # Initialize empty DataFrame
    maxes = pd.DataFrame(columns=df.columns)
    print(time_diffs)
    # Loop through time differences and DataFrame rows
    for i, time_diff in enumerate(time_diffs):
        print("NEW ELEMENT")
        # If adjacent rows fall within 24 hours of each other
        if time_diff <= pd.Timedelta('48 hours'):
            print("Same Day")
            print("Current:" + str(df.loc[i, 'Water Level']))
            print("Next:" + str(df.loc[i - 1, 'Water Level']))
            # If the second row's water level is greater
            if df.loc[i, 'Water Level'] < df.loc[i - 1, 'Water Level']:
                # Append the second row
                print("Less")
                if df.iloc[i - 1].name not in maxes.index:
                    maxes = maxes.append(df.iloc[i - 1])
                print("Maxes: ")
                print(maxes)
            else:
                print("Greater")
                # Remove the previous row with the same index as df.iloc[i-1]
                maxes = maxes.drop(index=df.iloc[i - 1].name, errors='ignore')

                # Append the first row
                maxes = maxes.append(df.iloc[i])

                print("Maxes: ")
                print(maxes)
        else:
            # Append the row
            print("Nothing happened")
            print("Current: " + str(df.iloc[i]))
            if (time_diff):
                maxes = maxes.append(df.iloc[i])
            print("Maxes: ")
            print(maxes)
    print(maxes)
    return maxes

    time_diff = (matched_dates['Date Time'].diff().dt.total_seconds() / 3600)
    # Create a boolean series (true if not same day or null)
    isSameDay = (time_diff > 24) | pd.isnull(time_diff)
    # filter out all values that lie on the same day
    filtered = time_diff[isSameDay]
    return filtered

def formatAndSave(df,fileName):
    # Fill missing High-High values and dates with High counterparts
    df['date_time_HH'].fillna(df['date_time_H'], inplace=True)
    df['HH_water_level'].fillna(df['H_water_level'], inplace=True)

    # Remove unneeded columns and Rename Water level and DateTime Columns
    df.rename(columns={'date_time_HH': 'Date Time', 'HH_water_level': 'Water Level'}, inplace=True)
    df.drop(
        columns={'date_time_H', 'H_water_level', 'date_time_L', 'L_water_level', 'date_time_LL', 'LL_water_level', },
        inplace=True)

    # Revert from DateTime indexing to linear Indexing
    df.index = pd.RangeIndex(start=0, stop=len(df))
    df.to_csv(f"./Filtered_Data/{fileName}_filtered.csv", index=False)
    return df